Singleton:
- Singleton ile oluşacak nesne örneği (instance) bir tanedir ve uygulama çalıştığı sürece aynı nesne kullanılmaya devam eder. 
- Her istekte aynı nesne kullanılır. 

Scoped:
- Scoped ile her istekte yeni bir nesne örneğinin oluşması ve aynı istek boyunca bu nesne kullanılmaya devam eder. 
- Eğer sayfa yenilendiğinde, yeni bir istek olacağı için yeni bir instance oluşturulur. 

Transient:
- Transient ile oluşturulmuş nesnenin her seferinde tekrardan örneğinin oluşturulması sağlanır. 
- Her enjekte edilmesinde veya istekte yeniden instance oluşturulur. 

Authentication ve Authorization (Kimlik doğrulama ve Yetkilendirme):
- Authentication,bir kullanıcının herhangi bir kaynağa erişimde kimliğinin doğrulanması işlemidir.
- Kullanıcıya Kimsin sorusu sorulur? Bu sorunun cevabı genellikle kullanıcının kullanıcı  adı ve  şifre şeklinde cevap vermesiyle yanıtlanır.
- Güvenliğin daha yüksek tutulması gereken durumlarda kullanıcı adı ve şifre ile beraber dijital sertifikalar kullanılarak güvenliğin arttırılması sağlanabilir.
- Authentication,authorization'dan önce gelmektedir.
- Authorization ise,kimliği doğrulanan kullanıcının erişmek istediği kaynak üzerindeki yetkilerini tanımlar.
  Dosya-klasör erişimleri,erişim saatleri,ayrılmış alan miktarı v.b.
- Authorization işleminin iki aşaması mevcuttur;
  1)Sistem yöneticisi erişilecek kaynak üzerinde izinleri tanımlar
  2)Erişilecek kaynağın üzerinde bulunduğu sistem veya uygulama kaynağa erişileceği zaman izinleri doğrular
- Peki authentication işlemi yapılmadan authorization işlemi yapılamaz mı?
- Kimsin sorusunun sorulmaması demek herhangi birisi anlamına gelir. 
- Dolayısı ile kimliği doğrulanmayan yani anonim kullanıcılara izin verileceği durumlarda bu işlem gerçekleştirilir.

- JWT açık bir standarttır (RFC 7519), amacı hizmetler arasında geçiş halindeki bilgileri JSON nesne biçiminde güvence altına almaktır.
- It consist of 3 parts, which are the Header, Payload and Signature
- Header or Authorization header describes the algorithm that is used to generate your token and type.
  Örnek:
  {
  "alg": "HS256",
  "typ": "JWT"
  }
- Bu örnekte, JWT tokeni HS256 algoritmasını ve bir tür jwt'yi içeren bir authorization header'ına sahiptir.
- İpuçları: Yapabiliyorsanız, sistemlerinizde kullanıcı başına algoritmayı değiştiren bir mimariye sahip olmak daha iyidir. 
  kullanıcı 1 HS256 algoritmasını kullanıyorsa, diğer yandan kullanıcı 2, birincisiyle aynı olmamalıdır.
- Payload, kullanıcı varlığınızı tanımlayan talepler veya ifadelerdir.
  Örnek:
  {
  "sub": "1234567890",
  "name": "Jeffrey Forones",
  "role": "admin",
  "userid": "user00001"
  }

- Gerçekte, yük, özellikle uygulanabilir bilgiler içeriyorsa, kısa ömürlü olmalıdır. 
- Bu durumda, sistemde bir güvenlik ihlalinin önlenmesi için bir fırsattır.
- Ek olarak, daha kısa bir son kullanma tarihi belirlemek hayati önem taşır. 
- Yaygın uygulama, son kullanma tarihinin 15 dakikadan fazla olmaması gerektiğidir.

- Signature; encoded header, payload ve Secret Key'in birleşimidir
- Secret Key, kriptografik iletişiminizde bir kez kullanılması gereken rastgele bir sayı veya dizedir. Bu örnekte, onu jwt'mizde kullanıyoruz.

Kısaca:
- Authentication, kısa ömürlü bir access token doğrulamak ve oluşturmaktır.
- Authorization, miktar kaynaklarını tüketiciyle sınırlamak ve access token kullanarak erişim haklarını doğrulamaktır.

Bearer Token:
- Bearer Token, Kimlik Doğrulama sunucusu tarafından sizin için oluşturulur. 
- Bir kullanıcı uygulamanızın (istemcinizin) kimliğini doğruladığında, kimlik doğrulama sunucusu gider ve sizin için bir token oluşturur. 
- Bearer Token'lar, OAuth 2.0 ile kullanılan baskın access token türüdür. 
- Bir bearer token temel olarak "Bu token taşıyıcısına erişim izni ver" der.
- Bearere token normalde kimlik doğrulama sunucusu tarafından oluşturulan bir tür opak değerdir. 
- Rastgele değildir; Size erişim sağlayan kullanıcıya ve uygulamanızın erişim sağladığı istemciye göre oluşturulur.
- Bearer token'lar HTTP isteğinin authorization header'ında ayarlanır.
  Örnek:
 
  POST /rsvp?eventId=123 HTTP/1.1
  Host: events-organizer.com
  Authorization: Bearer AbCdEf123456
  Content-Type: application/x-www-form-urlencoded
  User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/1.0 (KHTML, like Gecko; Gmail Actions)
  rsvpStatus=YES
 
- Yukarıdaki örnekte "AbCdEf123456" bearer tokendir.
- Bearer Token lar, OAuth V2 standardının bir parçasıdır ve birçok API tarafından yaygın olarak benimsenmiştir.

Swagger nedir:
- Web API geliştirmede en önemli ihtiyaçlardan biri dokümantasyon ihtiyacıdır. 
- Çünkü API methodlarının ne işe yaradığı ve nasıl kullanıldığı dokümantasyon içeresinde anlaşılır olması gerekir. 
- Api dokümantasyonunu el emeği ile yazmak hem zordur hemde güncel tutması imkansızdır. 
- Bir biçimde bu dokümantasyonu güncel olarak üretmek gerekir. 
- Burada imdadımıza swagger yetişiyor.
- Swagger’ın önemli bir amacı RestApi ler için bir arayüz sağlamaktır. 
- Bu hem insanların hemde bilgisayarlara kaynak koda erişmeden RestApi lerin özelliklerini görmesine, incelemesine ve anlamasına olanak sağlar.

Asenkron programlama:
- Multithread programlama farklı işlevlerin aynı anda yürütülmesiyle(parallelization) ilgilidir veya daha özeti kodun paralel olarak çalıştırılması diyebiliriz. 
- Başlattığımız thread’lerin aynı anda çalışması durumudur. 
- Bir thread başladığı andan itibaren diğer thread’lerin yaptıkları işlere bağlı olmaksızın paralel olarak çalışır ve sonlanır. 
- Bunu aklımızda canlandırmak için şöyle düşünebiliriz; 
  8 çekirdekli işlemcide 3 thread başlattığımızı düşünelim ve thread’lerin paralel çalışması demek her bir thread’e bir çekirdeğin atanması gibi düşünülebilir. 
  Böylece işlemcide çalışan 3 thread birbirinden bağımsız yani paralel olarak çalışabilecektir.

- Asenkron programlama ise içerisinde Multithread programla kavramını da içeren bir yapıdadır. 
- Temel olarak kodun çalışması sırasında bloklanmaması(non-blocking) gerektiği prensibine dayanır. 
- Bunu da task yapılarıyla sağlar. Uygulamamız birden çok thread içeren bir yapıda olsun ve bu thread’lerin ürettiği sonuçlara göre bazı işlemler yapıyor olsun. 
- İşte bu thread’leri bekleyip gelen sonuçlara göre işlem yapan ve uygulamayı kilitlemeden çalışmasını sağlayan rutinler asenkron programlamanın mantığını oluşturur.
- Yani temelde multithread programalama ve asenkron programlama arasındaki fark; 
  Thread yapılacak işlem odaklı çalışır, işlemin sonucunu alana kadar devam eder. Asenkron ise görevlerle ilgilidir.

- Bir görevin çalışması esnasında bekleme süreleri oluşabilir, bunun çok çeşitli nedenleri olabilir. 
- Örneğin dosya indirme işlemi içeren kod parçası indirme süresinde beklemeye neden olur veya disk işlemleri sırasında bekleme olabilir. 
- Bu bekleme sürelerine blocking denir. Buradaki temel düşünce blocking olduğu durumlarda başka bir görevin işlemleri yapılarak zamanın verimli 
  kullanılmasına dayanır.

- .Net dünyasında asenkron programlama için thread pool’dan thread çekiliyor ve çalıştırılan thread’lerin yönetimi sağlanıyor. 
- Bu süreci de Task yapıları ile sağlıyoruz. Task objesi temel olarak üstlendiği işleri thread pool üzerinde asenkron olarak çalıştırır. 

- async; içerisinde asenkron işlem yapılacak metodu belirtir. Benzer ifadeyle, içerisinde asenkron işlem yapacağımız metodu async keywordü ile işaretlemeliyiz.
- asnyc ile işaretlenmiş bir metodda asenkron çalışacak komutlar await ile işaretlenir. 
- async ile işaretlenmiş metodun geri dönüş tipi; void, Task veyahut Task<T> geri dönüş tiplerinde olmalıdır.
- await; sadece async ile işaretlenmiş metodlarda kullanılabilir.
- async ile işaretlenmiş bir metod birden fazla await kullanabilir.

- await kelimesi çalıştıracağı task’in işini bitirmesini beklerken diğer işlemlerin asenkron olarak devam etmesini sağlayan özelliği yani 
  non-blocking olarak çalışmayı sağlar.
- await sadece Task dönen durumlarda kullanılabilir, C# compiler Task dönmeyen metodlar için await kullanımında hata verecektir.
- Eğer Task dönmeyen senkron bir metodu çağırmak durumunda iseniz ve async ile etiketlenmiş bir metod içerisindeyseniz Task.Run kullanabilirsiniz.
- Compiler tarafında yeni bir thread açılarak kod bu thread içerisinde çalıştırılır. 
- Buradaki önemli noktalardan bir de Task.Run, Task döneceğinden await ile kullanılabilir.
  Örnek:

  await Task.Run(() => {
    for (int i = 0; i < 100; i++)
    {
       Console.WriteLine(i);
       Thread.Sleep(100);
    }
  });

- Task.Run kullanımlarının CPU bağlantılı işlerde kullanılması önerilmektedir. 
- CPU yapıları birden çok çekirdek içerdiğinden işlemci gücü gerektiren kodlamalarda Task.Run ile yeni bir thread açarak çekirdek işlem gücünden daha verimli 
  faydalanabilirsiniz. 
- Örneğin uygulamanızdaki main thread çok yoğun işlem yapıyor olabilir ve işlemci gücü gerektiren kodlamaları Task.Run ile yeni bir thread üzerinde 
  çalıştırdığınızda açılan bu thread farklı bir çekirdek üzerinde çalışacaktır(veya hangi çekirdek düşük işlemde ise onda çalışacaktır) bu nedenle 
  farklı çekirdek üzerinde çalışmanın getirdiği performans artışı elde edilmiş olacaktır.
- Eğer dosya işlemleri, ağ işlemleri gibi I/O operasyonları yapıyorsanız Task.Run önerilmez. 
- Bunun nedeni ise I/O işlemlerinde uzun süreli beklemeler olması ve bu durumun işlemci çekirdeğinin bir süre bekleme durumuna düşmesidir. 
- Sistem kaynaklarının verimsiz kullanımına neden olacak bu tip durumlara düşmemek için asenkron metodlar kullanmalısınız.
