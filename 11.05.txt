-----------Coupling ve Cohesion-----------

---Coupling:
- Coupling, modüller arasındaki karşılıklı bağımlılık derecesinin ölçüsüdür.
- Yani modüller arası bir kavramdır ve iki alt kavramı vardır. Bunlar; Gevşek Bağlılık (Loose Coupling) ve Sıkı Bağlılık (Tight Coupling)’dır.
- Tight Coupling ilişki içerisindeki modüller birbirlerine sıkı sıkıya bağımlıdır
- Bu bağımlılık, modüllerin birinde yapılacak değişikliğin diğer modülleri de etkilemesine sebep olur ve bu nedenle projenin bakım, 
  genişletilebilirliği ve maliyeti artar.
- Bunun önüne geçmek için yazılımın olabildiğince Loosely Coupled olması istenir. 
- Yani bir modül üzerinde yapılan değişikliğin diğer modüllere sıçramaması gerekir.

- Her gün gelişen teknoloji ile birlikte diller ve frameworkler de gelişimini sürdürüyor. 
- Gelişimle beraber projelere modüllerin ve yapıların eklenmesi ya da daha önemlisi mevcuduyla değiştirilmesi bir zorunluluk haline geliyor. 
- Bu zorunluklar kolaylıkla sisteme entegre edilebilsin ya da değiştirilebilsin diye bağımsız kodlar yazılmalıdır.
- Bir sınıfın kullandığı nesne, sınıf içerisinde new kelimesi ile oluşturuluyorsa iki sınıf birbirine kuvvetli bağlı hale gelir.
- Kodlarımızda kuvvetli bağlı yapılar kullandığımız takdirde bazı prensipleri hiçe sayarak projeyi zorlu bir süreç içerisine sokabiliriz.

Tight Coupling:
- Örnek 2 sınıf;

  class Otomobil
  {
	public string Calis()
  	{
      		return "Otomobil çalıştırılıyor.";
  	}
  	public string HareketEt()
  	{
      		return "Otomobil istenilen yönde sürülüyor.";
  	}
  }

  class Surucu
  {
    	Otomobil otomobil = new Otomobil();

    	public string Calistir()
    	{
		return otomobil.Calis();
    	}
    	public string Sur()
    	{
		return otomobil.HareketEt();
    	{
  }

- Surucu sınıfında Otomobil sınıfı new’lenerek sınıfın metotları kullanılıyor. Yani Surucu sınıfı Otomobil sınıfına sıkı sıkıya bağlıdır. 
- Dezavantajları şunlardır;
  
   => Sürücü sınıfı otomobil sınıfı olmadan bir iş yapamıyor. Tek başına işe yaramaz durumda.
   => Sürücü sınıfı başka bir modülde kullanılmak istendiğinde otomobil sınıfıyla birlikte kullanılmak zorunda kalacaktır. 
      Bağımlılığı yüzünden kod tekrarına sebebiyet verecek.
   => Surucu sınıfına başka bir araç kulladırmak istendiğinde mesela tır, kullanamayacak sadece otomobil kullanabilir durumda. 
      İçeriye yazılan şart bloklarıyla bu belki sağlanabilir ancak daha kolay yolu, bağımlılıkların azaltılmasıdır.

Loose Coupling:
- ilk akla gelen ve düz olan kodlama mantığı değiştirilmelidir. 
- Bu sıkı bağımlılıkların azaltılması için yapısal değişikliklerle abstract sınıflar ya da interfaceler kullanılır. 
- Böylece Surucu sınıfı birden çok araç kullanabilir hale gelebilir. Ve Surucu sınıfı kullanılacağı zaman, Otomobil sınıfından bağımsız bir şekilde 
  kullanılabilir hale getirilir. Peki ama nasıl?

  interface IArac
  {
	string Calis();
	string HareketEt(); 
  }

- Daha Sonra bu Interface Kullanılarak tır, otomobil ve otobüs vb bir sürü sınıf tanımlanabilir.

  class Otomobil : IArac
  {
  	public string Calis()
  	{
    		return "Otomobil çalıştırılıyor.";
  	}
  	public string HareketEt()
  	{
      	return "Otomobil istenilen yönde sürülüyor.";
  	}
  }

  class Tir : IArac
  	{
  	public string Calis()
  	{
    		return "Tır çalıştırılıyor.";
  	}
  	public string HareketEt()
  	{
      		return "Tır istenilen yönde sürülüyor.";
  	}
  }

  class Otobus : IArac
  {
  	public string Calis()
  	{
    		return "Otobüs çalıştırılıyor.";
  	}
  	public string HareketEt()
  	{
      		return "Otobüs istenilen yönde sürülüyor."
   	}
  }

- Daha sonra Surucu sınıfı şu şekilde oluşturulabilir;

  
  class Surucu
  {
    	private IArac _arac;  

    	public Surucu(IArac arac)
    	{
      		_arac=arac;
    	}
    	public string Calistir()
    	{
        	return _arac.Calis(); 
    	}
    	public string Sur()
    	{
       		return _arac.HareketEt();
    	{
  }

- Daha sonra Surucu istenilen şekilde oluşturulabilir.
  Örneğin;

  => Surucu s1 = new Surucu(new Otomobil());
  => Surucu s2 = new Surucu(new Tir());
  => Surucu s3 = new Surucu(new Otobus());

---Cohesion:
- Cohesion modülün elemanlarının işlevsel olarak ilişkili olma derecesinin bir ölçüsüdür.
- Yani bu da modül içi bir kavramdır. 
- Tek bir görevi gerçekleştirmeye yönelik tüm öğeler tek bir bileşen altında toplanmalıdır.
- Aynı zamanda SOLID prensiplerinin S harfini temsil eden (Single Responsibility Principle) bu tanım cohesion’u açıklar.
- Eğer bir modül içerisinde birbirinden bağımsız öğeler(metodlar, veriler) varsa bunlar olabildiğince ayrıştırılmalı ve modülün Yapışkan (High Cohesion) 
  olması sağlanmalıdır.

============ Özetle; yazılımın Loosely Coupled (Düşük Bağımlı) ve High Cohesion (Yüksek İlişkili — Yapışkan) olması gereklidir. ============

Dependency Injection:
- Dependency Injection’ı özetle anlatmak gerekirse; bağımlılık oluşturacak parçaların ayrılıp, bunların dışardan verilmesiyle sistem 
  içerisindeki bağımlılığı minimize etme işlemidir. 
- Yani, temel olarak oluşturacağınız bir sınıf içerisinde başka bir sınıfın nesnesini kullanacaksanız new anahtar sözcüğüyle oluşturmamanız 
  gerektiğini söyleyen bir yaklaşımdır. 
- Gereken nesnenin ya Constructor’dan ya da Setter metoduyla parametre olarak alınması gerektiğini vurgulamaktadır.
- Böylece iki sınıfı birbirinden izole etmiş olduğumuzu savunmaktadır. 
- Daha da özetlememiz gerekirse yazılımı oluşturan yapılar kaçınılmaz olarak birbirleri ile ilişkilidir. 
- Lakin bu ilişkinin bir bağa ve sınırlandırmaya sebep olmaması için mümkün mertebe ilişkiyi gevşek tutmak önemlidir. 
  Biz buna Loosely Coupled yani Gevşek Bağlılık diyoruz.
- Bundan dolayı yazılımı oluşturan yapıların birbirleri ile olan sıkı bağ azalacağı için uygulamaya yeni özellikler eklenip çıkartılabilmesi kolay hale gelecektir.
- Dependency Injection, bağımlılıkları soyutlamak demektir.

- DI, aşağıdaki iki teknikle uygulanabilmektedir.
  => Constructor Injection(Constructor Based Dependecy Injection)
  => Setter Injection(Setter Based Dependency Injection)

Constructor Injection(Constructor Based Dependecy Injection):
- Bu DI Türünde class constructor kullanılır.
  Örneğin;
  
  class Chad
  {
	public ITasit _tasit;
	public Chad(ITasit tasit)
    	{
		_tasit = tasit;
	}
  }

- Daha sonradan kullanılmak istendiğinde;
  => Chad c = new Chad(new Araba()); // Araba, tır, otobüs.....

Setter Injection(Setter Based Dependency Injection):
- Örnek;
 
  class GigaChad
  {
	public ITasit _tasit { get; set; }
  }

- Constructor injection'dan farklı olarak daha sonra kullanılmak istendiğinde şu şekil kullanılır;
  => GigaChad gc = new GigaChad();
     gc._tasit = new Araba();


==== Gördüğünüz gibi Dependency Injection kodunuzu özgürleştirmekte, sınıflar arasındaki bağı minimize etmektedir. ====
==== Sınıflar çalıştırılırken üzümü yiyen amma bağını sormayan olgunlukta olurlar.                                 ====


Inversion Of Control:
- Inversion of control bir yazılım tasarım prensibidir. 
- Ioc ile Uygulama içerisindeki obje instance’larının yönetimi sağlanarak, bağımlılıklarını en aza indirgemek amaçlanmaktadır. 
- Projeniz deki bağımlılıkların oluşturulmasını ve yönetilmesini geliştiricinin yerine, framework’ün yapması olarak da açıklanabilir.

- Inversion of Control’ün getirdiği avantajlar;
  => Bir methodun implementasyonundan izole bir şekilde çalıştırılabilmesini sağlar.
  => Farklı implementasyonlar arasında, kolayca geçiş yapabilmenizi sağlar.
  => Program modülerliğini artırır.
  => Bağımlılıklar en aza indiği için test etmeyi/yazmayı kolaylaştırır.


Clustered Index Scan:
- Index Scan, tablodaki her satıra nitelikli olsun ya da olmasın dokunur, maliyet tablodaki toplam satır sayısıyla orantılıdır.
- Bu nedenle, tablo küçükse veya satırların çoğu yüklem için uygunsa, tarama etkili bir stratejidir.

Clustered Index Seek:
- Index Seek yalnızca uygun olan satırlara ve bu uygun satırları içeren sayfalara dokunur.
- Maliyet, tablodaki toplam satır sayısı yerine uygun satır ve sayfa sayısıyla orantılıdır.


- Index, veri tabanı tabloları üzerinde tanımlanan ve veriye daha az işlemle daha hızlı ulaşan veri tabanı nesneleridir. 
- Indexler hakkında klasik bir örnek olarak telefon rehberi verilebilir. 
- Telefon rehberindeki kayıtların sıralı olmaması durumunda, yani her kaydın telefon defterinde rastgele tutulması durumunda, arayacağımız bir 
  isim için tüm rehberi gezmemiz gerekecek. Ama rehberinizdeki kayıtlar sıralı olsaydı, aradığımız ismin rehberin ortasındaki isimden ileride mi 
  yoksa geride mi olduğuna bakabilirdik. Bu şekilde aradığımız verileri eleyerek bir kaç adımda istediğimiz sonuca ulaşabilirdik. 
- Bu örnekteki gibi verinin sıralı tutulmasını sağlayan nesnelere index denir.

- Yeni bir veri tabanı oluşturduğumuzda veri tabanımızın bulunduğu dosyaları belirtiriz. 
- Sql Server bu dosyaları fiziksel olarak değil mantıksal olarak 8 KB’lık bloklara böler. 
- Bu bloklara page denir. Bundan dolayı dosyanın ilk 8 KB’ı page0, bir sonraki 8 KB’ı page1 olur ve bu şekilde devam eder. 
- Page’lerin içinde ise tablolardaki satırlara benzeyen ve adına row denilen yapılar bulunur. 
- Sql Server page’ler üzerinde başka bir mantıksal gruplama daha yapar; art arda 8 tane page’in bir araya gelmesiyle oluşan 64 KB büyüklüğündeki 
  veri yapısına extent denir. Bir extent dolduğunda; bir sonraki kayıt, kayıt boyutu büyüklüğünde yeni bir extent’e yazılır.
- Her page içinde bulunan satır sayısı aynı değildir. 
- Page’ler, veri büyüklüğüne göre değişen satırlara sahiptir ve bir satır sadece bir page içinde olabilir. 
- Sql Server aslında satırları okumaz bunun yerine page’leri okuyarak verilere ulaşır.


Index Çeşitleri
- Sql Server’da indexler temelde clustered ve non-clustered index olmak üzere ikiye ayrılır. 
- Leaf node’larda tutulan verinin kendisi ise clustered, verinin hangi pagede tutulduğunu gösteren pointer ise non-clustered index diye adlandırılır.

Clustered Index:
- Clustered index’ler tablodaki veriyi fiziksel olarak sıralar. 
- Bir tablo fiziksel olarak sıralandığından tablo üzerinde sadece bir tane clustered index tanımlanabilir. 
- Clustered index için seçilecek kolon veya kolonlar sorgulardaki en fazla kullanılan kolonlar olmalıdır.
- Veriler, bu kolonlara göre fiziksel olarak sıralanacağından çok hızlı erişilir.
- Ayrıca seçilen kolonun çok değiştirilmeyen bir alan olması gerekir. 
- Çünkü index’e ait kolonun değişmesi demek tüm index’in yeniden organize olması yani fiziksel olarak yeniden sıralanması anlamına gelir. 
- Sql server index ihtiyacını aslında kendisi belirler. Bizim tanımlayacağımız index’leri kullanıp kullanmamaya kendisi karar verir.

Non-Clustered Index:
- Non-Clustered Index veriyi fiziksel değil mantıksal olarak sıralar. 
- Bu index’lerin leaf node’larında verinin kendisi değil nerede olduğu bilgisi tutulur. 
- Tablo üzerinde en fazla 999 tane non-clustered index tanımlanabilir. 
- Non-clustered index’ler veriye doğrudan erişemez. 
- Heap üzerinden ya da bir clustered index üzerinden erişebilir. 
- Bu index’i oluştururken sorgumuzun koşul kısmında sık kullandığımız kolonlardan oluşturulması gerekir.

- Sql Server’da bir index en fazla 16 kolon içerebilir ve toplam boyutu 900 byte’ı aşmaması gerekir

Sunucu Çeşitleri

IIS:
- Internet Information Services, ASP.NET Core dahil olmak üzere web uygulamalarını barındırmak için esnek, güvenli ve yönetilebilir bir web sunucusudur.

Kestrel:
- ASP.NET Core uygulamarlında dahili olarak gelen bir web sunucusudur.

Nginx:
- Ubuntu/linux sistemlerde ASP.NET Core uygulamalarını çaıştırmamızı sağlayan bir sunucudur.
- Reverse Proxy olarak ASP.NET core uygulamalrındaki dahili sunucuyular (kestrel) işlevsellik gösterir.

Apache:
- Yine linux vb. gibi ortamlarda Apache ile ASP.NET Core uygulamarlınızı ayağa kaldırabilirsiniz.

Docker:
- Yazılım geliştiriciler ve sistem yöneticileri için geliştirilmiş açık kaynak olan yeni nesil bir sanallaştırma platformudur.

HTTP.sys:
- Yalnızca windows üzerinde çalışan ASP.NET Core içiçn bir web sunucusudur.
- Kestrel'e alterntif.







