Pagination:
- Örneğin içerisinde çok fazla veri olan bir veritabanından veri çekmemiz gerektiği zaman (10000 veri vb..) 10000 veriyi birden çekmektense
  ilk olarak ilk 30 veriyi, daha sonra 2. 30 veriyi vb vb çekmek daha performanslı bir yaklaşım olucaktır.

Port Exhaustion Nedir?
- Port Exhaustion, bir cihazda başka bir cihaz ile iletişim kurmak üzere uygun durumda port bulunmadığı için soket oluşturulamaması problemine verilen isimdir 
- Port Exhaustion’ın sık görülmesinin sebebi TCP portlarının bağlantı sonrası paket kaybı ihtimaline karşılık Time_Wait durumunda bekletilmesidir. 
  Bu süre default olarak 60 saniyedir.
- Öyleyse kısa süreli çok sayıda bağlantı açıp kapatan istemciler, proxyler ve yük dağıtıcılarda birçok port Time_Wait durumunda kalabilir ve 
  sistem Port Exhaustion durumuna düşebilir.

- Detaya inersek HttpClient’ın IDisposable’dan türediğini görebiliriz.
- Öyleyse HttpClient’ımızı Using içine alalım?
- Maalesef HttpClient ile ilgili en yanlış bilinen şeylerden biri bu. HttpClient’ın dispose edilişi açılan soketlerin kapatılmasını sağlamıyor, 
  zaten dikkatli incelerseniz Time_Wait’e sebep olan örnek programın da HttpClient’ı using içinde kullanmış olduğunu görebilirsiniz.
- Microsoft’un önerdiği şekilde, static bir HttpClient tanımlamak bu sorunun önüne geçmek için yapabileceğimiz en iyi seçenek gibi duruyor. 
  Program boyunca kullanılacak tek bir client oluşturmak.
- Bu sorunumuzu büyük ölçüde çözüyor. Fakat buradaki problem ise statik olarak tanımlanan client’ın dns değişikliklerini göremiyor olması…

IHttpClientFactory ve HttpClient in doğru kullanımı: 
- HttpClient .NET içerisinde built in olarak bulunan bir frameworktur
- HttpClient kullanarak Get Post Delete Put methodlarını kullanabilmekteyiz.
- Ancak eğer HttpClient kullanılarak oluşturlan objelerle ilgili 2 sorun bulunmaktadır

  => Eğer manuel olarak bu nesneleri dispose etmezsek memory leaklerine sebep olabiliriz.
  => Bu instance için kullanılan socket serbest kalmayabilir ve buda socket exhaustiona sebep olabilir.

- Dispose etmek için using kullanabiliriz; 
  using var client = new HttpClient();

- Ancak bu şekilde dispose etme sorunundan kurtulmuş olsak bile socket exhaustion halen geçerilidir.
- using kullanarak otomatik bir şekilde instance'ı dispose edebiliyoruz ancak socketler otomatik olarak serbest kalmıyorlar.
- Ayrıca her HttpClient instance'ı oluşturulduğunda HttpMessageHandler instance'ı da oluşturulur ki buda socketi kitleyen şeydir.
- Bunu çözmenin bir yoluda oluşturacağımız HttpClientlarını singleton olarak oluşturmak ancak bu şekilde yaptığımızda uygulamada ileriki süredeki oluşucak
  dns değişikliklerini tespit etmemiz imkansız hale gelir
- Bu iki sorundan kurtulmak için ise IHttpClient kullanırız

- IHttpClient, HttpClient larının lifecyclelarının yönetmek için tanıtılmıştır.
- IHttpClient kullanmanın bir kaç yolu vardır.
- Bunlardan biri manuel olarak client oluşturmak;
 
  => Bunun için öncelikle program.cs dosyasının içerisine servis olarak kaydetmemiz gerekir
     builder.Services.AddHttpClient();

  => Daha sonra IHttpClientFactory i DI ile kullanabilriz;

      private readonly IHttpClientFactory _httpClientFactory;

      public Service(IHttpClientFactory httpClientFactory)
      {
          _httpClientFactory = httpClientFactory;
      }

      public async Task Foo()
      {
	  using var httpClient = _httpClientFactory.CreateClient();
      }

- Artık bundan sonra instance kendiliğinden dispose olucak ve socket exhaustion yaşamıycaktır.

Named Clients:
- HttpClient ımız için bazı customizationlar ekleyebiliriz. (Örneğin base url, default headers ekleme..)
- Bu tarz durumlar için IHttpClientFactory named clientlar ile çalışmaya izin verir
- Bunu yapmak için program.s içerise eklediğimiz servise bir takım değişiklikler yapalım

  => builder.Services.AddHttpClient("MyClient", httpClient =>
     {
        httpClient.BaseAddress = new Uri("https://www.example.com/");
        httpClient.DefaultRequestHeaders.Add(HeaderNames.Accept, "application/json");
        httpClient.Timeout = TimeSpan.FromMinutes(1);
     });

- Daha sonradan bu clientı kullanmak için ismi belirtmemiz grekir.

  private readonly IHttpClientFactory _httpClientFactory;

  public Service(IHttpClientFactory httpClientFactory)
  {
     _httpClientFactory = httpClientFactory;
  }

   public async Task Foo()
   {
       using var httpClient = _httpClientFactory.CreateClient("MyClient");
   }


