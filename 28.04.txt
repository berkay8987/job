Entity Framework Core:
- Entity Framework Core, Entity Framework'un açık kaynaklı, lightweight ve cross plaform versiyonudur.
- Geliştiricilerin .NET objelerini kullanarak ilişkisel veritabanlarını kullanmalarını sağlayacak bir ORM tool'udur.
- Lightweight ve extendable olacak ve Microsoft'un .NET Core çerçevesinin bir parçası olarak platformlar arası geliştirmeyi 
  destekleyecek şekilde tasarlanmıştır.
- Ayrıca, kullanımı daha basit olacak ve Entity Framework'ün önceki sürümlerine göre performans iyileştirmeleri sunacak şekilde tasarlanmıştır.
- EF Core bir nesne ilişkisel eşleştiricidir (ORM: Object Relational Mapper).
- Object Relational Mapper, geliştiricilerin, bir uygulamanın programlama dilinde tanımlanan nesneler ile ilişkisel veri kaynaklarında depolanan veriler arasında 
  eşlemek için gereken işi gerçekleştirerek verilerle nesne yönelimli bir şekilde çalışmasını sağlayan bir tekniktir.
- EF Core, verileri sorgulama, ekleme, güncelleme ve silme gibi veritabanı işlemlerini yönetmek için bir dizi API sağlar ve SQL Server, MySQL, SQLite ve PostgreSQL 
  dahil olmak üzere çok çeşitli ilişkisel veritabanlarını destekler.
- EF Core, geliştiricilerin C # veya Visual Basic kullanarak etkileyici ve verimli sorgular yazmasına olanak tanıyan linq'i (Language Integrated Query) destekler.
- EF Core ayrıca lazy loading, değişiklik izleme ve önbelleğe alma gibi performansla ilgili çeşitli özellikler sunar. 
- Ek olarak, geliştiricilerin, bellek içi bir koleksiyonu nasıl sorgulayacağınıza benzer şekilde verileri sorgulamak ve filtrelemek için 
  LINQ (Language Integrated Query) kullanmasına olanak tanır.

Why Use ORM?
- Nesne yönelimli bir programlama dili kullanarak bir veritabanıyla etkileşimde bulunmak için bir ORM (Object Relational Mapper) kullanılır. 
  Orm'ler, geliştiricilerin ham SQL ifadeleri yazmak yerine tanıdık, nesne yönelimli kavramlar kullanarak veritabanlarıyla çalışmasına izin verir.
- Bu, geliştirme sürecini daha verimli ve daha az hataya açık hale getirmenin yanı sıra kod tabanının daha kolay bakımını sağlayabilir.
- Ek olarak, orm'ler genellikle uygulama performansını artırabilecek önbelleğe alma, yavaş yükleme ve bağlantı havuzu oluşturma gibi özellikler sağlar.
- Ayrıca, uygulama ile veritabanı arasında bir soyutlama katmanı sağlarlar, böylece uygulama kodu temeldeki veritabanı şemasındaki değişikliklerden yalıtılabilir.
- Bu, gelecekte farklı bir veritabanına geçmeyi kolaylaştırabilir veya verileri birden çok sunucuya dağıtarak ölçeklenebilirliği artırabilir.
- Genel olarak, orm'ler geliştirici verimliliğini, kod sürdürülebilirliğini ve uygulama performansını artırmaya yardımcı olabilir.

- Çoğu development frameworks, kayıt kümesi benzeri veri yapıları aracılığıyla ilişkisel veritabanlarından verilere erişim sağlayan kitaplıkları içerir. 
  Aşağıdaki kod örneği, verilerin bir veritabanından alındığı ve bir veritabanında depolandığı tipik bir senaryoyu gösterir. ADO.NET DataTable, böylece programın 
  koduna erişilebilir:

  using(SqlConnection conn = new SqlConnection(connectionString))
  {
      SqlCommand cmd = new SqlCommand("select * from Products", conn)
      DataTable dt = new DataTable();
      using(SqlDataAdapter da = new SqlDataAdapter(cmd))
      {
          da.Fill(dt);
      }
  }

- DataTable içindeki verilere sayısal veya dize dizinleyicileri aracılığıyla erişilebilir ve nesneden doğru türe dönüştürülmesi gerekir:

  foreach(DataRow row in dt.Rows)
  {
      int productId = Convert.ToInt32(row[0]);
      string productName = row["ProductName"].ToString();
  } 

- Veri erişimine bu late-bound veya "weakly typed" yaklaşım hataya eğilimlidir.
- Sorunlar genellikle bir sütunun adının yanlış yazılmasından, sütunun adının veritabanında değiştirildiğini bulmasından veya uygulama kodunda 
  karşılık gelen bir değişiklik yapılmadan alanların SQL deyiminde belirtilme sırasına göre bir değişiklikten kaynaklanır.
- Aynı şekilde, veri türü dönüşümleri başarısız olabilir. 
- Kod yine de derlenir, ancak çalışma zamanında hata verir.
- Sonuç olarak, profesyonel geliştiriciler verilerle güçlü bir şekilde yazılmış bir şekilde çalışmayı tercih eder.

Entity Framework Özellikleri:
- Cross Platform: EF Core, Windows, Linux ve Mac dahil olmak üzere çeşitli platformlarda kullanılabilir.
- Lightweight: Entity Framework Core, Entity Framework'ün tam sürümünden daha küçük bir ayak izine ve daha az bağımlılığa sahiptir.
- Code First: EF Core, geliştiricilerin daha çevik ve test odaklı bir geliştirme iş akışı sağlayan koddan bir veritabanı oluşturmasına olanak tanır.
- LINQ Support: EF Core, geliştiricilerin C # veya Visual Basic kullanarak verimli ve okunabilir sorgular yazmasına olanak tanıyan güçlü ve etkileyici bir 
                sorgu dili olan linq'yu destekler.
- Support For Multiple Databases: EF Core, SQL Server, MySQL, SQLite ve PostgreSQL dahil olmak üzere çok çeşitli ilişkisel veritabanlarını destekler.
- Migrations: EF Core, veritabanı geçişlerini oluşturmak ve yönetmek için built in desteğe sahiptir ve bu da zaman içindeki veritabanı 
              değişikliklerinin kolay yönetilmesini sağlar.
- Performance Improvements: EF Core performans için optimize edilmiştir ve büyük veri kümelerini verimli bir şekilde işleyebilir.
- Many to many ilişkileri ve tablo bölme desteği.
- Client Evaluation ve Lazy Loading desteği.
- Explicit loading, change tracking ve caching (önbelleğe alma) desteği.

Strong Typing:
- Entity Framework Core (EF Core), .NET platformu için bir ORM (Nesne-İlişkisel Eşleme) çerçevesidir. EF Core'un en önemli özelliklerinden biri, 
  güçlü yazım desteğidir.
- EF Core ile çalışırken, varlıklar olarak bilinen C # sınıflarını kullanarak veritabanı şemanızı tanımlarsınız, bu sınıflar daha sonra veritabanındaki 
  ilgili tablolarla eşleştirilir.
- Entity'ler strong typed olarak yazıldığından, derleyici şema ile ilgili hataları çalışma zamanında değil derleme zamanında yakalayabilir.
- Ek olarak, EF Core, veritabanındaki verileri sorgulamak için LINQ (Dille Tümleşik Sorgu) kullanımını destekler; bu, verileri sorgulamak 
  için güçlü bir şekilde yazılmış, etkileyici ve kullanımı kolay bir API sağlar.
- Entity'ler strongly typed olarak yazılan bir yaklaşım uyguladığınızda, nesne yönelimli bir şekilde etki alanı modeli oluşturan önceden tanımlanmış 
  sınıfların özellikleriyle çalışırsınız:

  public class Product
  {
      int ProductId { get; set; }
      string ProductName { get; set; }
  }
  Product myProduct = new Product();
  int productId = myProduct.ProductId;
  string productName = myProduct.ProductName;

- Halen veritabanındaki veriyi çekip, nesneye eşlemek gerekiyor
- Bir seçenek, bunu yönetmek için kodunuzu yazmaktır.
- Ancak, domain modeli büyüdükçe, gereken kod miktarı artabilir ve bakımı için giderek daha fazla geliştirme süresine ihtiyaç duyacaktır. 
- Bu, bir application tamamlamak için gereken toplam süreyi artıracaktır.
- Orm'ler, bu işi sizin için yapan önceden yazılmış library'lerdir. Tam özellikli orm'ler de çok daha fazlasını yapabilirler;
  => bir domain modelini veritabanı nesnelerine eşleme
  => veritabanları oluşturmak ve şemayı modeldeki değişikliklere göre korumak
  => SQL oluşturun ve veritabanına karşı yürütün
  => manage transactions
  => önceden veritabanından alınmış nesneleri yönetin
 
ADO.NET:
- ADO.NET (ActiveX Data Objects.NET) , Aktivex tabanlı çalışan, Microsoft’un veri erişim teknolojisidir.
- ADO.NET, geliştireceğimiz uygulamamız ile Database arasında tam bir Köprü görevi görür. Verileri okuyabilir, update edebiliriz. 
- SQL sorguları ve procedure leri çalıştırtabiliriz. Bu sebeptendir ki , veri tabanı bağlantılı geliştirdiğimiz tüm uygulamamızda kullanmamız 
  gereken en önemli teknolojidir
- ADO.NET ile ilgili kullanacağımız tüm class lar, Microsoft’un “using System.Data” adlı kütüphanesinde mevcuttur. 
  Ve bizde tüm işlemlerimizde bu kütüphanemizden faydalanacağız.
- ADO.NET ‘in veri tabanına 2 tür bağlantı şekli vardır.; Connected, Disconnected

Connected Bağlantı Şekli:
- Bu bağlantı şeklimizde, Uygulamamız, database ile sürekli bağlantılı haldedir ve anlık database de okuma ve update işlemlerimiz yapılmaktadır.
- Bağlantı sürekli olduğu için, veri okuma işlemi son satırı okuyana kadar açık kalması gerekmektedir, bu da uygulamamızda biraz yavaşlığa sebep olabilir.
- Örnek vercek olursak: Mesela, sql de bir tablomuzda satır satır dönme işlemlerimiz, yada direk bir sorgu yada procedure komutlarımız Connected bağlantı 
  şekline girmektedir.

- Command : Sorgularımızı yada Procedure lerimizi çalıştırmamıza yarayan sınıftır. Database çeşidine göre farklılık gösterir.  
          (SqlCommand, OleDbCommand, OdbcCommand, OracleCommand) gibi.
- DataReader : Sorgu sonucumuzda elde ettiğimiz veride , satır satır dönmemize yarayan sınıftır. Database çeşidine göre farklılık gösterir.

Disconnected Bağlantı Şekli:
- Bu bağlantı şeklimizde, Uygulamamız, veri tabanını kullanmak için sürekli ona müracaat etmek yerine, veri tabanının bir kopyasını RAM üzerine alır 
  ve bundan sonraki tüm işlemlerini RAM deki veri üzerinde yapar.
- RAM ‘e alınan veri üzerinde, insert, update ve delete işlemleri kolaylıkla yapılır ve bu işlem için database ‘e kadar gitmemize gerek yoktur. 
- Fakat anlaşılacağı gibi yaptığımız değişiklikler RAM ‘deki veri üzerinde olmaktadır. 
- Gerçek database deki değişiklik için ayrıca bir işlem gerektirir.
- Bu bağlantı şeklinin en önemli avantajı performanstır. Çünkü bilmemiz gereken en önemli şeylerden biri, veri tabanına bağlantı framework açısından 
  her zaman zahmetli bir iştir ve bize yavaşlık getirir. 
- Bu modelde, veri tabanına 1 kere bağlanılmakta ve istediğimiz veriyi RAM e aldıktan sonra bir daha database ‘e gitmemize gerek kalmamaktadır.
- Dezavantajı ise, Gerçek database deki verilerin güncellenmesi geç yapıldığı için, zaman zaman veri uyuşmazlığı ve tutarsızlığı yaşanmaktadır.
- Bu bağlantı şekline örnek olarak: Sahada kullanılan bir çok el terminalleri bu mantıkla çalışmaktadır. 
  El terminallerine sabah veriler yüklenir (RAM e yükleme aşaması) , ve gün boyunca cihazlar ile bigli girişleri yapılmaktadır. 
  Bunların hepsi cihazdakiş RAM de tutulur, ve gün sonunda cihazlar internete bağlandıktan sonra gerçek database ile Senkronizasyon işlemi yapılır. 
  Yani database ‘e sadece 2 defa gidilir. Buda bize performans sağlamaktadır. 

IEnumerable ve IQueryable :
- IEnumerable tüm verileri alıp memory de tutarak, sorgulama işlemlerini memory üzerinden yaparken IQueryable ise şartlara bağlı query oluşturarak 
  doğrudan veritabanı üzerinden sorgulama işlemi yapar. Eğer milyonlarca kayıt üzerinde sorgulama işlemi yapıyorsak elbette 
  IQueryable IEnumerable göre daha hızlı sorgulama işlemi yapar.
- IEnumerable hafızadaki koleksiyonlar için idealdir.
- IQueryable hafıza dışındaki (veritabanı, servis vs.) koleksiyonlar için idealdir.
- IQueryable fazladan CreateQuery ve Execute yöntemlerine sahiptir. Bu şekilde doğrudan özel sorguları yazıp çalıştırabiliriz. IEnumerable bunu desteklemez.
- IEnumerable lazy loading özelliğini desteklemez. IQueryable lazy loading özelliğini destekler. 
















