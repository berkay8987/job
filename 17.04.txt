- Geçmiş günlerin notların okundu.

DRY, KİSS, YAGNİ NEDİR?

- Hepimiz bir proje geliştirirken özellikle araya zaman girdiğinde nerede ne yaptığımızı unuttuğumuz veya takım arkadaşımızın kodunu anlamadığımız olur. Bu sorunları en aza indirmek için tasarlanmış bazı programlama prensipleri vardır. Bu  
  prensipler; güzel, açık ve sürdürülebilir kod yazmak istiyolarsa mühendislerin program uygulaması sırasında izlemeleri gereken bir dizi öneridir.

- DRY: Dont Repeat Yourself.
  => Kod yazarken kendimizi sürekli tekrara sokmamız gerekir. Hem kodun daha düzenli olması hem de daha sonradan başkaları tarafından okunucağı zaman daha anlaşılabilir olmasını ve hem de zamandan tasaffur sağlatır.
  => Çok fazla kendimzi tekrar edersek kodun test edilebilirliği ve sonrasında o işlem için tekrar kullanılabilirlik açısından problemlere karşılaştığımız yazılımda çok kullanılan spagetti koda döner.
  => Eğer aynı amaca hizmet eden iki veya daha fazla kod varsa bunları soyutlama yoluyla ortadan kaldırılmasını belitirtir ve tekrarlama otomasyon yoluyla ortadan kaldırılır.

- KISS: Keep It Simple, Stupid
  => Tasarım veya tasarımmların ve/veya sistemlerin mümkün olduğunca basit olması gerektiğini belirtir.
  => Kiss prensibini uygulamaya koyabilmek için önce sorununuzu birkaç küçük soruna bölün
  => Yöntemlerinizi küçük tutun. Her yöntem yalnızca bir sorunu çözmelidir, pek çok kullanım durumunu değil.
  => Ve her şeyi mümkün olduğunca basit tutmaya çalışın

- YAGNI: You Ain't Gonna Need It
  => Yagni ilkesi, özelliklerin yalnızca gerektiğinde eklenmesi gerektiğini belirten bir yazılım geliştirme uygulamasıdır. Aşırı programlama (XP) felsefesinin bir parçası olarak, istenen artan sürüm sıklığını kolaylaştırmak için  
     geliştirmedeki fazlalığı ve verimsizliği ortadan kaldırır.
  => Geliştirme aşamasında ileride lazım olacağını düşündüğümüz kısımları projemize eklemek isteyebiliriz. İşte tam burada YAGNI bize dur diyor. Bu tür işlemler geliştirme sırasında vakit kaybı olmasının yanı sıra yanlış öngörülme 
     sonucu ileride de tekrar bir ek çaba gerektirecektir. Ne kadar iyi analiz edip sürecin geliştirildiği düşünülse de bu pek öyle çıkmaz. Bunun sonucunda harcanan analiz, programlama ve test etme süreleri için boş yere vakit kaybetmiş   
     oluruz.
  => YAGNI, kullanılmayacak özelliklere zaman harcamaktan kaçınmaya yardımcı olduğundan, bir programın ana özellikleri daha iyi geliştirilir ve her sürümde daha az toplam zaman harcanır. Worse is Better ilkesine çok benzeyen yagni, 
     ekstra özelliklerin geliştirlmesine karşıdır ve özellik kaymasını önlemeye yardımcı olur.
     
- SoC: Seperation of Concerns
  => SoC, yazılımdaki elemanların kendilerine özel olmasını, sorumlulukların kendilerine ait olup, başka elemanlar ile paylaşmamasını söyler. 
  => Sorumlulukların ayrı olmasının gerekliliği bu prensibin altını çizdiği temek noktadır. 
  => Yazılımı geliştirirken, "sınır" diyebiliceğimiz kavramlar bu sorumlulukları birbirinde ayıran en net ifadeler olabilir.
  => Genelde bu sorumlulukları belirlerken çok küçük parçalara kadar inmeye çalışırız. Çok küçük parçalardan daha önemli olan sorumluluk kümelerinin net ve ayrı olabilmesidir. Einstein'in "Make everything as simple as possible but not 
     simpler" lafına benzer şekilde sorumlulukları olabildiğince küçük parçalara ayır ama daha küçültme. Benzer şekilde sorumluluklarıda küçük parçalara ayır ama daha küçültme...
  => Sorumluluk kümelerini iyi bir şekilde oluşturmazsak, ayrık ayrık bir sürü parça sisteminde kaybolur gider. 
  => Yazılım içindeki bileşenlerin birbirine bağlılık derecesi (coupling) ve bileşenler içerisindeki sorumluluk ilişkisi (cohesion), SoC prensibi için önemli iki kavramdır. Bileşenlerin bağlılık derecesi düşük olması ve bir bileşen
     içindeki sorumluluk ilişkisinin yüksek olması her zaman tercih edilmelidir. Yani low-coupling ve high-cohesion olmazsa olmazdır. 
  => Bu sayede bağlılık derecesi düşük olursa, sorumluluklar bileşen başına dağılmış olacağından yazılımın kontrolu bizim elimide daha kolay olacaktır. Bileşenler içerisindeki sorumluluklarında birbirine yakın olması yeniden 
     kullanılabilirliği ortaya çıkaracaktır.


SOLID PRENSIPLERI:

- SOLID, her yazılımcının bilmesi gereken temel prensipler bütünüdür. Robert C. Martin tarafından ileri sürülen ve kısaltması Michael Feathers tarafından düşünülen bu prensiplerin amacı; kod tekrarına düşmeyerek, sürdürülebilir
  anlaşılabilir, esnek ve yeniden kullanılabilir yazılımlar geliştirmektir.
- SOLID prensipleri bir yazılım geliştricisinin OOP ile yazılım geliştirirken, geliştirdiği yazılımın esnek ve geliştirlmeye uygun olması için uyması gereken kurallar bütünüdür. Bu prensipler doğrultusunda geliştirdiğimiz. Uygulamalarımız
  ne kadar büyük olursa olsun, karmaşıklık asla söz konusu olmaz. Spagetti kod dediğmiz karmaşık kod yerine clean cod yazmamızı yine bu prensipler sağlamaktadır.
- Dünya standartlarında yazılım geliştirmemize olanak sağlayan bu prensipleri 5 ana başlıkta ele alabiliriz.
  
  => S - Single Responsibility Principle (SRP)
  => O - Open/Closed Principle (OCP)
  => L - Liskov's Substitution Principle (LSP)
  => I - Interface Segregation Principle (ISP)
  => D - Dependancy Inversion Principle (DIP)

============================================================================================================================================================================================================================================

S - Single Responsibility Principle: 
- Bu prensipte amaç, geliştirilen projede bir güncelleme veya değişiklik yapılması istendiğinde kodların içinde kaybolmadan, yalnızca ilgili metoda giderek istenilen değişikliğin yapılmasının sağlanmasıdır. Biraz daha açacak olursak
  bir fonksiyona birden fazla iş verip onu birçok işten sorumlu tutmak yerine, her bir iş için ayrı bir metot oluşturulmalı ve ilerleyen zamanlarda bir değişiklik yapılacağında da kolaylıkla ilgili metoda giderek gerekli değişiklikleri 
  yapabilmeliyiz.
- Yani her sınıfın veya metodun tek bir sorumluluğu olmalı.
  Örneğin; bir robotu hem mutfak robotu hem bahçe robotu hem boya robotu yapmaktansa, her bir iş için ayrı bir robot yapmalıyız.
  Daha kodsal bir örnek vermek gerekirse;
  SendMail adında bir sınıf oluşturduğumuzu düşünelim. Bu sınıf içerisinde iki adet metod var; SendMailForX ve IsMailAdressValid.
  
  class SendMail
  {
	public bool SenMailForX(string input, string mailAdress)
	{
		// Check if mail legit
		if (!IsMailAdressValid(mailAdress))
		{
			return false;
		}
		
		// Do stuff...

		return true;
	}

	public bool IsMailAdressValid(string mailAdress)
	{
		// Check the mail...

		return true;
  	}
  }

- Bu şekilde kod yazdığımızda SOLID'in S si olan SingleResponsiblity prensibine aykırı kod yazmış oluyoruz. Çünkü SendMail sınıfnın işi mail göndermek, mailin gerçek olup olmadığını kontrol etmek değil.
- Bu yüzden IsMailAdressValid metodu bu sınıfın içerisinde olmamalıdır.

  class MailAdressValidator
  {
	public bool IsMailAdressValid(string mailAdress)
	{
		// Check the mail..
		return true;
  	}
  }

  class SendMail
  {
	
	private MailAdressValidator validator = new MailAdressValidator();

	public bool SenMailForX(string input, string mailAdress)
	{
		// Check if mail legit
		if (!validator.IsMailAdressValid(mailAdress))
		{
			return false;
		}
		
		// Do stuff.
		return true;
	}
  }

- Kodu bu şekilde düzeltmek doğru olacaktır.

============================================================================================================================================================================================================================================

O - Open/Closed Principle:
- Bu prensip, projede geliştirilen nesnelerin geliştirilmeye açık ama değişime kapalı olmaları gerektiğin ifade eder. Yani bir nesne davranışını değiştirmeden yeni özellikler kazanabiliyor olmalıdır. Bu prensip, sürdürülebilir ve tekrar 
  kullanılabilir yapıda kod yazmanın temelini oluşturur.
- Sınıflarımız veya metotlarımız oluştururken ileride olabilecek yeni istekler ve gelişmeleri de öngörerek tasarlamamız gerekir. Projemizde oluşabilecek yeni istek ve ihtiyaçlar sonucunda yapacağımız geliştirmeler, projemizdeki diğer
  sistemleri etkilememeli ve herhangi bir değişikliğe sebep vermemelidir.
  Örneğin;
  
  class File
  {
	public void SaveToFile(string fileType, string value)
	{
		if (fileType == "txt")
		{
			// ...
		}

		else if (fileType == "xml")
		{
			// ...
		}
	}
  } 

  Bu class yapısını incelediğimizde hangi dosya türüne kaydedilmek isteniyorsa her dosya için if bloğu yazılıyor.
  Daha sonradan yeni bir dosya eklemek istediğimizde sürekli if blokları yazmak zorunda kalıcağız.

  abstract class File
  {
	public abstract void SaveToFile(string value)
  }

  class TXTFile : File
  {
	public override void SaveToFile(string value)
	{
		// ...
	}
  }

  class XMLFile : File
  {
	public override void SaveToFile(string value)
	{
		// ...
	}
  }

  Daha sonradan yeni bir dosya türü eklemek istediğimizde sadece yeni bir class oluşturup File'dan türetmemeiz yeterli olucaktır.

============================================================================================================================================================================================================================================

L - Liskov's Substitution Principle:
- Prensibe adını veren kadın Barbara Liskov tarafından, ki kendisi MIT'de profesör, 1988 yılında Data Abstraction and Hierarchy adlı kitabında ilk defa bu kendi ismini taşıyan prensibi ortaya koymuştur.
- Tanım olarak: alt sınıflar miras aldığı üst sınıfın bütün özelliklerini kullanmalı, alt sınıflarda oluşurulan nesneler üst sınıfların nesneleriyle yer değiştirdiklerinde aynı davranışı göstermeli ve herhangi bir kullanılmayan
  özellik olmamalı.

????????

============================================================================================================================================================================================================================================

I - Interface Segregation Principle:
- Arayüz ayrımı prensibinde, bir interface'e gerekenden fazla sorumluluk eklemek yerine, daha özelleştirilmiş birden fazla interface oluşturulmalıdır. Nesneler, ihtiyacı olmayan özellik veya metotlar içeren interface'leri miras almaya
  zorlanmamalıdır. "Single Responsibility"ye benzer. Ancak burada gözden kaçırılmaması gereken şudur ki: Interface Segregation prensibi interface'ler ile ilgilenirken, Single responsibility prensibi class'lar ile ilgilenmektedir.
- Interface'ler içinde sadece metotların imzaları bulunur. Bir interface bir class'a implemet edildiği zaman, interface'in barındırdığı metotları barındırmak veya oluşturmak zorundadır
- İşte bu durumda prensip devreye girer ve derki "eğer class içerisinde gerçekten ihtiyaç duyulmayan ve kullanılamayan metotlar interface aracılığıyla implement edilmiş ise bu kodlar dumy kod olur, bu yüzden interface'ler ayrımlaı ve 
  class'lar açısından işlevsel olmayanmetotlar barındırması engellenmelidir.

============================================================================================================================================================================================================================================

D - Dependency Inversion Principle:
- Bu prensibe göre, alt sınıflarda yapılan değişiklikler üst sınıfları etkilememelidir yani sınıflar arası bağımlılıklar olabildiğince az olmalıdır ve özellikle üst veiye sınıflar, alt seviye sınıflara bağımlı olmamalıdır. 
- Burada yüksek seviye sınıf ile düşük seviye sınıf arasında bir soyutlama katmanı oluşturarak her iki sınıfı da soyut kavramlar üzeridenn yönetmeliyiz.
- Buradaki amaç üst seviedeki modullerin alt seviyelere bağımlı olmasından dolayı çıkabilecek sorunları oradan kaldrımaktır. Yani alt seviede yapılan herhangi bir değişiliğin üst seviyede kod değişikliğine veya onun bağlılıklarının
  etkilenmesine engel olmaktır.
- Daha kaba bir anlatım ile üst seviyedeki modül alt seviyedeki işin nasıl yürüdüğünü bilmemeli ve ilgilenmemelidir. Ben üst seviyedeki modul olarak diyorum ki; alt taraftan x verisinin nasıl geldiği ile ilgilenmem, bana gelen x 
  verisi ile ilgili işlemimii yapar, gerekli yerlere gönderirim. Ama x verisi bir veri tabanından mı geldi, bir API 'den mi geldi yoksa bir txt dosyasından mı okunarak geldi burası beni ilgilendirmze. Zaten bu gibi isteklerinde beni 
  etkilememesi gerekmektedir.

============================================================================================================================================================================================================================================

ASP.NET nedir:
- ASP.NET, HTML, CSS ve JS ile dinamik web sayfaları, web siteleri, uygulamalar ve hizmetler üretmek için web geliştirme için tasarlanmış açık kaynaklı bir sunucu tarafı web uygulama çerçevesidir.
- Ayrıca Web API'Leri, mobile siteler oluşturabili, web soketleri gibi gerçek zamanlı teknolojileri kullanabilisiniz.
- ASP.NET micorsoftun geliştirmiş olduğu web uygulama geliştirme frameworkudur. 
- Klasik ASP'nin üzerinde önemli geliştirmeler yapılarak oluşturulmuştur.
- ASP.NET modern bir teknolojidir ve web sayfaları, web uygulamaları ve XML servisleri hazırlanmasına olanak sağlar.
- ASP.NET code behind denilen tasarım öğeleri ile programlama öğelerini birbirinden ayrı sayfalarda bulunduran bir özelliği destekler.
- Bu özellik sayesinde bir proje üzerinde tasarımcı ve programcı aynı anda çalışabilir.
- ASP.NET teknolojisi oldukça hızlıdır, eski ASP'ye göre her seferinde sayfaların tekrar tekrar okunarak her istekte bir request olmasını engelleyerek, daha hızlı ve daha performanslı çalışmasını sağlar.
- ASP.NET kullanıcıları için bir çok arayüze sahiptir. Email formları, veritabanı listeleyicileri gibi bir çok komponent bulunmaktadır.

ASP.NET CORE nedir:
- 2016 yılında tanıtıtlan ASP.NET CORE .NET teknolojileri ile yazılım geliştirme çalışmaları yapan geliştricilerin daha duyarlı, güvenilir ve genişletilebilir uygulamlar geliştirebilmelerini kolaylaştırmaktdaır.
- ASP.NET CORE tüm ASP.NET altyapısının yeniden tasarlanılarak, WEB API ve MVC altyapıları ile birleştirilmesii sağlamıştır.
- ASP.NET Core içerisinde bir çok kütüphane ve optimizasyon aracı bulundurmaktadır. Bu araçlar sayesinde daha srğdürebilir, yüksek performanlsı yazılımlar oluşturulabilmektedir.
- Hızlı sürüm döngüleri, kolay güncellemeler, bellek optimizasyonları ve boşlık ayırma gibi özellikler altyapıyı mobil içinde çok uygun bşr hale getirmektedir.
- Bir web uygulaması geliştirildiğinde uygulamaını tğm platformalarda sorunsuz bir şekilde çalışması gerekmektedir. Cross platform support olarak adlandırılan bu özellik ASP.NET CORE tarfındanda desteklenmektedir.
- ASP.NET CORE MacOS, Linux ve Windows işletim sistemleri üzerinde sorunsuz çalışmaktadır.

Peki ASP.NET ile ASP.NET CORE arasındaki fark nedir?
- ASP.NET CORE aslında ASP.NET'in yeniden dizayn edilererk bir çok konseptinin değiştirildiği yeni bir teknolojidir.
- Üstelik cross platform çalışabilmek için geliştirilmektedir.
- Diğer bir değişle uygulamalarınızı sadece IIS'te Windows bir makinede host etmek zorunda değilsiniz.


MVC Mimarisi:
- ModelViewController kelimelerinin baş harflerinden kısaltılarak oluşturulan özellikle web uygulamarlı geliştirmek için oluşturulumuş bir tasarım modeli
- Adından da anlaşılacağı gibi 3 ana bölümü vardır girdi süreç çıktı.
- MVC ASP.NET ile özdeşleştirilsede ilk olarak 1979 yılında ortaya çıkmıştır.
- Günümüzde MVC denilince ilk akla gelen Microsoft'un geliştridği ASP.NET MVC Framework olmasısın nedeni web projeleri için yapısının uygun olmasıdır.
- Microsoft tarafından geliştirilmemiştir!!!
- Peki Model, View, Controller nedir?

- Model: Uygulamalarda kullanılan verileri temsil eder ve verilerin işlenme mantığının saklandığı kısımdır. 
         Adındanda anlaşılacağı üzere veri yönetimi burada yapılır.
         Burayı salt veriyi temsil eden sınıf olarak görmemeliyiz; model katmanı veriye erişim sınıfları ve iş mantığını da barındırır.

- View: Basitçe uygulamamızın kullanıcıların gördüğü kısmıdır, arayüzüdür.
 	  Uygulamanın arayüz yapılarını (layout, button, edittext vb) barındırır, bunun yanında kullanıcıdan gelen hareketleri (click , scroll vs) presenter'a iletir.
 	  Android'de view interface'lerini activity ve fragment'lar implement eder böylece android geliştirmede en sık karşılaşılan god object'den korunmuş olunur.

- Controller: Model ve view arasında getir götür işlemlerini gerçekleştirir.
  	 	  MVC yapısında ana mantık Model ve View yapısının ayrılmasıdır.
   	 	  Bu iki yapı arasındaki haberleşmeyi sağlayan köprüye controller denir.
		  Projedeki tüm işlemlerin (veritabanı işlemleri, hesaplamalar, veri aktarımı) gibi işlemlerin yapıldığı kontrol bölümüdür.
   	 	  Controller ayrıca model ve view arasındaki veri akışınıda kontrol eder.

- Presenter: MVP (Model View Presenter) kalıbının kalbinde yer alır, diğer modülleri koordine eder. 
             Genelde model'den hizmet alıp view'ı günceller.

- Bu modele göre, bir öğe başka bir yere bağlanmalı veya bağlantılı olması gerekir. UI mantığı, görünümü veya ön ucuyla ilgilenir. Giriş mantığı denetleyiciyle ilgilenir. Son olarak, iş mantığı bir çözüm modeliyle ilgilenir. Bu gevşek 
  bağlı öğe, geliştiricilerin herhangi bir sürümü oluştururken karmaşık çözüme yardımcı olur. (burayı anlamadım)

MVC Mimarisini kullanmanın yararları:
- Herhangi bir kontrolördeki ilgili eylemlerin mantıksal kümelenmesi mvc aracılığıyla sağlanabilir.
- Çeşitli geliştiriciler, aynı uygulama denetleyicisi, modeli ve görünümleri parçası gibi farklı parçalar üzerinde aynı anda çalışbilir.
- MVC'de modeller çok sayıda görünüme sahip olabilir.

Peki neden MVC mimarisi:
- Asıl olaya gelirsek özetle, MVC sayesinde Model ve View yapısını ayrıştırmış oluyoruz.
- Böylelikle yarın bir gün uygulamamızın görünümünü değiştirmek durumunda kaldığımızda "yalnızca" görünümle uğraşmamız gerekecek
- İç içe geçmiş spagetti kodla uğraşmak durumunda kalmış olsaydık, sadece görünümünü değiştirmek isterken uygulamanın işleyişinide değiştirmek durumunda kalcaktık. (Hatta bunu yaparken yanlışlıkla işleyişide bozabiliriz)

Önemli Noktalar:
- Controller sadece aracı görevi görüyor. İş mantığı Model'de, görsel mantık View'da olmalı; Controller sadece haberleşmeyi sağlamalı. Controller'a, Model'in ve/veya View'ın sorumlulukları yüklenirse MVC kullanmanın hiç bir anlam
  yok.
- Hakkından bahsettiğimiz sebepten ötürü Fat Model, Skinny Controller yapısını kurgulamamız lazım. MVC kullanmamızın algoritmayı Controller'a sıçratırsak hiçbir kazancı kalmıyor
- MVC sadece web tabanlı projelerde kullanılıyormuş gibi gelse de, Masaüstü / Mobil uygulama geliştirirken de MVC kullanılabilir. Zira MBC bir mimari biçimdir. 

API:
- Application Programming Interface
- Web'de çalışabilen ve web uygulamaları, işletim sistemleri, veritabanları, donanımlar yahut yazılım kütüphaneleri ile iletişim kurabilen bir arayüzdür
- Direkt olarak web uygulaması yaklaşımı diyemeyiz. Lakin genellikle web tabanlı uygulamalarda client ve server arasındaki iletişimi sağlayan bir sözleşme olarak kullanılmaktadır. Bu forma Web API ismi verilmektedir.


ASP.NET CORE Proje Oluşturma ve Dosya Yapısı: .NET CORE 5 İÇİN GEÇERLİ!!!!!
Program.cs:
- ASP.NET uygulamaları esasında bir consol uygulamasıdır.
- ASP.NET CORE kendi dahilinde sunucu barındırır. İşte o sunucuyu ayağa kaldırdığı nokta Program.cs dosyasıdır.
- Program.cs içerisinde ayağa kaldırılıcak host'un kullanacağı konfigürasyonları nereden alacağını bildirmektedir.
- Temel konfigürasyon sınfı startup'tır
Startup.cs:
- Web uygulamasında belirli konfigürasyonları yaptığımız dosya startup.cs dir.
- Startup.cs içerisinde iki temel metot bulunur; ConfigureServices, Configure.
- Bu uygulamada kullanılacak servislerin eklendiği yani konfigüre edildiği metot ConfigureServices'dir.
- "Servis" nedir?: Belirli işlere odaklanmış ve o işlerin sorumluluğunu üstlenmiş kütüphaneler/sınıflar. Servis = modül/kütüphane.
- Bu uygulamada kullanılacak middleware'lerimizi (ara katman/ara yazılım) çağırdığımız metot Configure'dir.
Appsettings.json:
- Appsettings uygulamada belirli static değeleri tuttuğumuz bir konfigürasyon dosyasıdır.
- Yazılımlarda bazen uygulamanın her yerinde kullanmak isteyeceğimiz metinsel değerler olabilir. (Veri tabanı bağlantı string'i)
- Bu değerler birden fazla yer tarafında tüketilebilir. 
- Yazılımlarda kullanılması gereken static olan metinsel değerler kodun içerisine yerleştirilmez.
- Her yere kodun içerisine yerleştirirsek, gün gelince değiştirmek istediğimizde gidip bütün yerleştirdiğimiz yerlerde değiştirmemiz gerekir.
- Bu durum zaman tüketicek ve maliyetli olucaktır.
- Böyle maliyetlerden kaçınabilmek için static olan metinsel değerleri appsettings.json dosyasında tutmaktayız.
Appsettings.development.json:
- Environment'lara göre appsettings tanımlanır.
- Şuan geliştirme aşamasındaolduğu için development aşamasındadır.
Properties:
------
launchSettings.json:
- Environment profillerini yönettiğimiz bir penceredir.
Dependencies:
- Kullandığımız bütün kütüphaneler, framework'ler uygulamalarda bir bağımlılık olarak nitelendiriliyor.

- Uygulama ayağa kaldırıldığında önce Program.cs çalışıcak, gerekli host build edilicek. Ardından Startup.cs'den gerekli konfigürasyonlar alınıcak ve uygulama hangi davranışa hangi modele hangi yaklaşıma benimsiyosa o yaklaşımda gerekli
  şekilde çalışmaya başlıycaktır.

MVC Gençay Yıldız Versiyon (Yukarıda yazdıklarımı farklı farklı sitelerden birleştirip yazmıştım, bu yazıcaklarım full gençay yıldıza ait.):
- MVC, birbirinden bağımsız üç katmanı esas alan bir mimarisel desendir.
- Özünde Observer, Decorator gibi design pattern'ları kullanan bir mimarisle desendir.
- Microsoft bu desen üzeine oturtulmuş ASP.NET CORE 'u geliştirmiştir.

Model:
- İşlenecek olan veriiy temsil edne katmandır. Genellikle veritabanı işlemlerinin yapıldığı katmandır.
- Entity Framework Core, Entity Models, Ado.NET, Repository, Veritabanı işlemleri

View:
- İstek neticesinde elde edilen verileri görselleştirecek, görsel çıktısının verecek katmandır.
- HTML, CSS, JavaScript, Razor, Resim, Müzik, Video

Controller:
- Gelen request'leri karşılayacak olan ve request'in içeriğine göre gerekli model işlemlerini üstlenecek oan katmandır.
- Algoritmaları, servisleri, veritabanını vs. çağırarak/çalıştırarak/sorgulayarak istenilen veriyi üretmekten ve ihtiyaç dahilinde üretilen bu veriyi View ile görselleştirmekten sourmludur.
- İstek neticesinde elde edilen ve işlenen veriyi tekrardan client'a response olarak döndürür.

ASP.NET CORE MVC PIPELANE:
- Gelen request Kestrel sunucu tarafında karşılancak.
- Middleware'ler çalışıcak
- Routing katmanına gelicek ve gerekli route işlemleri gerekli endpointler ayıklanıcak.
- Controller Initialization, controller isteği karşılıycak ve yapılan istek karşılığında gerekli işlemleri yapıcak.
- Action Method Execution, controller içerisinde yapılan isteğe gerçekten cevap verecek methodlar, gerekse model'a bağlancak gerekse view'a göndercek.
- Üretilen veri ya direk client'a gönderilecek ya da view'e gönderilecek ve render edilicek ve bu client'a gönderilcek.

ASP.NET CORE MVC proje altyapısı oluşturma, Boş bir ASP.NET CORE uygulamasını MVC mimarisine bağlama:
- Boş bir ASP.NET CORE porjesi oluşturduktan sonra Startup.cs içerisindeki Configure methoduna services.AddControllerWithViews(); deyip MVC mimarisinde çalışıcağımızı belirtiriz.
  .NET CORE 6.0 için => Program.cs içerisnde builder.Services.AddControllerWithViews();
- ASP.NET CORE uygulamasında MVC mimarisini kullanabilmek için uygulamada Controller ve Views yapılanmalarının eklenmesi gerekmektedir.
- Bunun için öncelikle bu servis uygulamaya eklenir. Böylece uygulama MVC davranışı sergiliycektir.
- Gelen isteğin rotası app.UseRouting() bu middleware sayesinde belirlenir.
- Endpoint: yapılan isteğin varış noktası yani url. İstek Adresi. Bu uygulamaya gelen isteklerin hangi rotalar/Şablonlar eşliğinde gelebileceğini burada bildireceğiz.
